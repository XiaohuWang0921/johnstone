Monic Endomorphisms on the Subobject Classifier
===============================================

This is a formalization of a [proof](https://ncatlab.org/toddtrimble/published/Monic+endomorphisms+on+the+subobject+classifier) of the so called [_Johnstone's exercise_](https://ncatlab.org/nlab/show/subobject+classifier#johnstones_exercise), which states that every monic endomorphism on the subobject classifier of a topos is an involution, i.e. a self-inverse isomorphism.

The proof is formalized in [Lean](https://leanprover.github.io/), [Coq](https://coq.inria.fr/) and [Arend](https://arend-lang.github.io/), interpreting the type of all propositions (`Prop` in Lean and Coq, `\Prop` in Arend) as the subobject classifier, assuming the axiom of propositional extensionality (`propext` in Lean, `PropExtensionality.propositional_extensionality` in Coq and `propExt` in Arend, which is rather a theorem than an axiom). No further axiom is used in the proof (in Arend the functional extensionality is also used, but again this is just a theorem that follows from the properties of the `Path` type rather than an axiom).

I have made the somewhat unusual choice of writing the proof completely in functional style, i.e. without using tactics, even in Coq, since this seems to be one of the rare cases where Coq's poor support for dependent pattern-matching does not give me a headache. Also I have spared myself the effort of writing any comments. If you are confused and would like to know what my code is doing, please email me and I will arrange a meeting to explain what I did, since I, an unfortunate extrovert with social anxiety, am in grave need for human interactions within my comfort zone.

Important Edit
--------------
In the introduction above, I complained about what I called "Coq's poor support for dependent pattern-matching". Turns out, I was naive and simply didn't understand very well how pattern-matching in Coq works. I was too used to Haskell-style pattern-matching using functional equations, which is also the syntax employed by Agda and Idris, and got frustrated when I couldn't also use it in Coq.

However, now that I have a better understanding of pattern matching in Coq, I actually quite like it. Sure, Agda's syntax using functional equations is very intuitive, but it also has the disadvantage of being somewhat more verbose, and that you'd have to explicitly introduce a named function every time you want to use the syntax. Coq's pattern-matching syntax on the other hand is more concise and standalone, and can be used anywhere a term is expected, without having to introduce an auxiliary function. Moreover, Coq's pattern-matching syntax can in fact be implemented in Agda as well, however only as a common operator rather than a builtin language-level construct. Hence its syntax is less flexible, and using too much of it might even confuse the Agda compiler.